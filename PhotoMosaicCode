import argparse, os, math, random
from pathlib import Path

import numpy as np
from PIL import Image, ImageOps, ImageDraw

# -----------------------------
# Helpers
# -----------------------------
def load_image_rgb(path):
    im = Image.open(path).convert("RGB")
    return im

def center_square_crop(img: Image.Image) -> Image.Image:
    w, h = img.size
    s = min(w, h)
    left = (w - s) // 2
    top = (h - s) // 2
    return img.crop((left, top, left + s, top + s))

def resize_nearest(img: Image.Image, size):
    return img.resize(size, Image.NEAREST)

def avg_color_np(arr_small):
    # arr_small: HxWx3 uint8
    return arr_small.reshape(-1, 3).mean(axis=0)

def draw_grid_lines(canvas: Image.Image, cell, color=(0,0,0), width=1):
    draw = ImageDraw.Draw(canvas)
    W, H = canvas.size
    for x in range(0, W + 1, cell):
        draw.line([(x, 0), (x, H)], fill=color, width=width)
    for y in range(0, H + 1, cell):
        draw.line([(0, y), (W, y)], fill=color, width=width)

def srgb_to_linear(c):
    c = c / 255.0
    return np.where(c <= 0.04045, c / 12.92, ((c + 0.055)/1.055)**2.4)

def color_dist(a, b):
    # simple distance in linear RGB for better matching than raw sRGB
    la = srgb_to_linear(a)
    lb = srgb_to_linear(b)
    return np.linalg.norm(la - lb)

# -----------------------------
# Core
# -----------------------------
def build_mosaic(
    target_path,
    sources_dir,
    out_path,
    cell_size=20,
    max_width=None,
    reuse_limit=0,          # 0 = unlimited reuse per source
    blend_back=0.0,         # 0..1 amount of original target (pixelated) blended over tiles
    grid_lines=False,
    grid_color=(0,0,0),
    grid_width=1,
    export_tiles_dir=None,
    seed=42
):
    random.seed(seed)

    # ---- Load and prep target
    target = load_image_rgb(target_path)
    if max_width and target.width > max_width:
        h = int(target.height * (max_width / target.width))
        target = target.resize((max_width, h), Image.LANCZOS)

    # force dimensions to be multiples of cell_size
    W = (target.width // cell_size) * cell_size
    H = (target.height // cell_size) * cell_size
    if (W, H) != target.size:
        target = target.crop((0, 0, W, H))

    cols = W // cell_size
    rows = H // cell_size
    print(f"Grid: {cols} x {rows}  |  Cell: {cell_size}px  |  Size: {W}x{H}")

    # A pixelated version of target (useful for blending back)
    small = target.resize((cols, rows), Image.BILINEAR)
    target_pixelated = small.resize((W, H), Image.NEAREST)

    # Precompute per-cell average colors for target
    target_arr = np.asarray(small, dtype=np.uint8)  # rows x cols x 3
    cell_avg_colors = target_arr.reshape(rows, cols, 3)

    # ---- Load / prepare sources
    src_paths = []
    for p in Path(sources_dir).glob("*"):
        if p.suffix.lower() in [".jpg", ".jpeg", ".png", ".webp", ".bmp", ".tif", ".tiff"]:
            src_paths.append(p)
    if not src_paths:
        raise RuntimeError("No source images found in the provided folder.")

    # Cache: for each source, store its center-cropped, resized tile (at cell_size) and average color
    tiles = []
    for p in src_paths:
        try:
            im = load_image_rgb(p)
            im = center_square_crop(im)
            # Pre-resize a medium size for color averaging faster
            med = im.resize((32, 32), Image.LANCZOS)
            avg = avg_color_np(np.asarray(med, dtype=np.uint8))
            tiles.append({
                "path": p,
                "img": im,         # keep original square (will resize later to avoid double resampling)
                "avg": avg,
                "used": 0
            })
        except Exception as e:
            print(f"Skipping {p.name}: {e}")

    if not tiles:
        raise RuntimeError("No usable source images after loading.")

    print(f"Loaded {len(tiles)} source images.")

    # ---- Build output
    canvas = Image.new("RGB", (W, H), (0,0,0))

    # Optional export folder for per-tile PNGs
    if export_tiles_dir:
        exp_dir = Path(export_tiles_dir)
        exp_dir.mkdir(parents=True, exist_ok=True)

    # For each cell, choose best-matching tile by color (respecting reuse_limit if set)
    for r in range(rows):
        for c in range(cols):
            target_color = cell_avg_colors[r, c].astype(np.float32)

            # rank candidates by distance
            ranked = sorted(
                tiles,
                key=lambda t: (t["used"] if reuse_limit > 0 else 0, color_dist(t["avg"], target_color))
            )

            # pick first that respects reuse limit (if any)
            choice = None
            for tinfo in ranked:
                if reuse_limit == 0 or tinfo["used"] < reuse_limit:
                    choice = tinfo
                    break
            if choice is None:
                # everyone hit the limit; allow reuse by picking the best anyway
                choice = ranked[0]

            # resize and paste
            tile_img = choice["img"].resize((cell_size, cell_size), Image.LANCZOS)
            x0 = c * cell_size
            y0 = r * cell_size
            canvas.paste(tile_img, (x0, y0))
            choice["used"] += 1

            # export individual tile if requested
            if export_tiles_dir:
                out_name = f"tile_r{r:03d}_c{c:03d}_{choice['path'].stem}.png"
                tile_img.save((exp_dir / out_name).as_posix())

        # simple progress
        if (r+1) % 10 == 0 or r == rows - 1:
            print(f"Row {r+1}/{rows} complete")

    # Optional: blend back the pixelated target for recognizability
    if blend_back > 0:
        blend_back = max(0.0, min(1.0, blend_back))
        canvas = Image.blend(canvas, target_pixelated, alpha=blend_back)

    # Optional: draw grid lines
    if grid_lines:
        draw_grid_lines(canvas, cell_size, color=grid_color, width=grid_width)

    # Save
    out_path = Path(out_path)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    canvas.save(out_path.as_posix())
    print(f"Saved mosaic: {out_path.resolve()}")

# -----------------------------
# CLI
# -----------------------------
def main():
    ap = argparse.ArgumentParser(
        description="Build a square-tile photo mosaic: fill each grid cell with the best-matching source image."
    )
    ap.add_argument("-t", "--target", required=True, help="Target image to reproduce as a mosaic.")
    ap.add_argument("-s", "--sources", required=True, help="Folder with many images to use as tiles.")
    ap.add_argument("-o", "--output", default="mosaic.png", help="Output mosaic image path.")
    ap.add_argument("--cell", type=int, default=20, help="Tile (cell) size in pixels. Default: 20")
    ap.add_argument("--max-width", type=int, default=None, help="Resize target max width (keeps aspect).")
    ap.add_argument("--reuse-limit", type=int, default=0, help="Max times each source can be used (0 = unlimited).")
    ap.add_argument("--blend", type=float, default=0.0, help="Blend 0..1 of pixelated target over mosaic for clarity.")
    ap.add_argument("--grid", action="store_true", help="Draw gridlines on top of mosaic.")
    ap.add_argument("--grid-color", type=str, default="0,0,0", help="Gridline RGB, e.g., '0,0,0' or '255,255,255'")
    ap.add_argument("--grid-width", type=int, default=1, help="Gridline thickness in px.")
    ap.add_argument("--export-tiles", type=str, default=None, help="Folder to export each placed tile PNG.")
    ap.add_argument("--seed", type=int, default=42, help="Random seed (affects tie-breaking).")
    args = ap.parse_args()

    grid_color = tuple(int(x) for x in args.grid_color.split(","))

    build_mosaic(
        target_path=args.target,
        sources_dir=args.sources,
        out_path=args.output,
        cell_size=args.cell,
        max_width=args.max_width,
        reuse_limit=args.reuse_limit,
        blend_back=args.blend,
        grid_lines=args.grid,
        grid_color=grid_color,
        grid_width=args.grid_width,
        export_tiles_dir=args.export_tiles,
        seed=args.seed
    )

if __name__ == "__main__":
    main()
