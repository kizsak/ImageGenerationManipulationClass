import argparse, random
from pathlib import Path
from typing import Tuple, Optional
from PIL import Image, ImageChops, ImageDraw, UnidentifiedImageError

# ---------------- Utilities ----------------

def choose_frame(frames_dir: Path) -> Path:
    frames = [*frames_dir.glob("*.png"), *frames_dir.glob("*.webp")]
    if not frames:
        raise FileNotFoundError(f"No frame images found in {frames_dir}")
    p = random.choice(frames)
    print(f"[INFO] Using frame: {p}")
    return p

def fit_cover(img: Image.Image, size: Tuple[int, int]) -> Image.Image:
    """Scale+crop to cover a target box (like CSS background-size: cover)."""
    W, H = size
    r = img.width / img.height
    R = W / H
    if r > R:
        # image wider than box
        new_h = H
        new_w = int(round(H * r))
    else:
        new_w = W
        new_h = int(round(W / r))
    resized = img.resize((new_w, new_h), Image.LANCZOS)
    left = (new_w - W) // 2
    top = (new_h - H) // 2
    return resized.crop((left, top, left + W, top + H))

def screen_blend(base: Image.Image, top: Image.Image) -> Image.Image:
    """Screen blend with alpha on 'top'."""
    b = base.convert("RGBA")
    t = top.convert("RGBA").resize(b.size, Image.LANCZOS)
    br, bg, bb, ba = b.split()
    tr, tg, tb, ta = t.split()
    sr = ImageChops.invert(ImageChops.multiply(ImageChops.invert(br), ImageChops.invert(tr)))
    sg = ImageChops.invert(ImageChops.multiply(ImageChops.invert(bg), ImageChops.invert(tg)))
    sb = ImageChops.invert(ImageChops.multiply(ImageChops.invert(bb), ImageChops.invert(tb)))
    rgb_screen = Image.merge("RGB", (sr, sg, sb))
    out_rgb = Image.composite(rgb_screen, Image.merge("RGB", (br, bg, bb)), ta)
    return Image.merge("RGBA", (*out_rgb.split(), ba))

def scale_alpha(img: Image.Image, opacity: float) -> Image.Image:
    r, g, b, a = img.convert("RGBA").split()
    a = a.point(lambda v: int(v * max(0.0, min(1.0, opacity))))
    return Image.merge("RGBA", (r, g, b, a))

def punch_window_alpha(frame: Image.Image, bbox, feather: int = 2) -> Image.Image:
    """Ensure the frame has a truly transparent hole inside bbox."""
    L, T, R, B = bbox
    L += feather; T += feather; R -= feather; B -= feather
    L = max(0, L); T = max(0, T); R = max(L + 1, R); B = max(T + 1, B)
    r, g, b, a = frame.split()
    keep = Image.new("L", frame.size, 255)
    draw = ImageDraw.Draw(keep)
    draw.rectangle([L, T, R, B], fill=0)
    a2 = ImageChops.multiply(a, keep)
    return Image.merge("RGBA", (r, g, b, a2))

# --------------- Main ----------------

def main():
    ap = argparse.ArgumentParser(description="Light leak + random Polaroid frame.")
    ap.add_argument("--input", required=True, help="Input photo")
    ap.add_argument("--frames-dir", required=True, help="Folder of frame PNGs")
    ap.add_argument("--overlay", default=None, help="Specific light-leak file (png/jpg/webp)")
    ap.add_argument("--overlay-dir", default=None, help="Folder of light-leaks (pick one randomly)")
    ap.add_argument("--overlay-opacity", type=float, default=0.75, help="0..1 for leak strength")
    # Fractions so one set of numbers works for every frame size.
    ap.add_argument(
        "--window-frac",
        default="0.148,0.083,0.852,0.769",  # tuned from your good 1080x1080 window
        help="L,T,R,B as fractions of width/height (e.g., 0.148,0.083,0.852,0.769)"
    )
    ap.add_argument("--debug", action="store_true", help="Save red-box preview of window")
    ap.add_argument("--outdir", default="output")
    args = ap.parse_args()

    outdir = Path(args.outdir); outdir.mkdir(parents=True, exist_ok=True)

    # 1) Load the chosen frame and compute the window from fractions
    frame_path = choose_frame(Path(args.frames_dir))
    frame = Image.open(frame_path).convert("RGBA")
    fw, fh = frame.size
    fL, fT, fR, fB = [float(x) for x in args.window_frac.split(",")]
    L = int(round(fL * fw)); T = int(round(fT * fh))
    R = int(round(fR * fw)); B = int(round(fB * fh))
    bbox = (L, T, R, B)

    # Debug red box image
    if args.debug:
        dbg = frame.copy()
        d = ImageDraw.Draw(dbg)
        d.rectangle([L, T, R - 1, B - 1], outline=(255, 0, 0, 255), width=3)
        dbg_path = outdir / f"DEBUG_window_{frame_path.stem}.png"
        dbg.save(dbg_path, "PNG")
        print(f"[DEBUG] Saved: {dbg_path}")

    # Make sure the hole is truly transparent
    frame = punch_window_alpha(frame, bbox, feather=2)

    # 2) Prep the photo and apply a light leak
    photo = Image.open(args.input).convert("RGBA")

    ov_path: Optional[Path] = None
    if args.overlay:
        p = Path(args.overlay)
        if p.exists():
            ov_path = p
    elif args.overlay_dir:
        d = Path(args.overlay_dir)
        cand = [*d.glob("*.png"), *d.glob("*.webp"), *d.glob("*.jpg"), *d.glob("*.jpeg")] if d.exists() else []
        if cand:
            ov_path = random.choice(cand)

    if ov_path:
        try:
            print(f"[INFO] Using overlay: {ov_path}")
            ov_img = Image.open(ov_path).convert("RGBA")
            ov_img = scale_alpha(ov_img, args.overlay_opacity)
            photo = screen_blend(photo, ov_img)
        except UnidentifiedImageError:
            print(f"[WARN] Skipping unreadable overlay: {ov_path}")

    # 3) Fit photo into window and composite
    win_w, win_h = max(1, R - L), max(1, B - T)
    fitted = fit_cover(photo, (win_w, win_h))
    canvas = Image.new("RGBA", frame.size, (0, 0, 0, 0))
    canvas.paste(fitted, (L, T))
    composed = Image.alpha_composite(canvas, frame)

    out_name = f"polaroid_{Path(args.input).stem}__{frame_path.stem}.png"
    out_path = outdir / out_name
    composed.save(out_path, "PNG")
    print(f"Saved: {out_path}")

if __name__ == "__main__":
    main()
