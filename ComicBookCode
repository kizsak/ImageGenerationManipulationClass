#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
comic_frame.py
Turn a photo into a comic-book panel with:
- Posterized (flat) colors
- Bold inked edges
- Ben-Day halftone dot overlay
- White border + optional caption box
- Optional speech bubble

Requirements: opencv-python, Pillow, numpy
"""

import argparse
import math
import os
from typing import Tuple, Optional

import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont


# ---------------------------
# Utility
# ---------------------------
def parse_xy(s: str) -> Tuple[int, int]:
    x, y = s.split(",")
    return int(x), int(y)

def load_font(size: int, preferred: Optional[str] = None) -> ImageFont.FreeTypeFont:
    # Try a user-supplied font path first, then common fonts, then default
    candidates = []
    if preferred:
        candidates.append(preferred)
    candidates += [
        "/System/Library/Fonts/Supplemental/Impact.ttf",          # macOS Impact
        "/Library/Fonts/Impact.ttf",
        "C:\\Windows\\Fonts\\impact.ttf",                         # Windows Impact
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",   # Linux
    ]
    for p in candidates:
        if os.path.isfile(p):
            try:
                return ImageFont.truetype(p, size=size)
            except Exception:
                pass
    return ImageFont.load_default()

def pil_to_np(img: Image.Image) -> np.ndarray:
    return np.array(img.convert("RGB"))[:, :, ::-1]  # RGB->BGR for OpenCV

def np_to_pil(arr_bgr: np.ndarray) -> Image.Image:
    return Image.fromarray(arr_bgr[:, :, ::-1])  # BGR->RGB


# ---------------------------
# Comic Effects
# ---------------------------
def posterize_kmeans(bgr: np.ndarray, k: int = 8, iters: int = 10) -> np.ndarray:
    """Reduce colors with k-means for punchy comic colors."""
    h, w = bgr.shape[:2]
    data = bgr.reshape(-1, 3).astype(np.float32)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 1.0)
    flags = cv2.KMEANS_PP_CENTERS
    compactness, labels, centers = cv2.kmeans(data, k, None, criteria, iters, flags)
    centers = np.clip(centers, 0, 255).astype(np.uint8)
    quant = centers[labels.flatten()].reshape(h, w, 3)
    # gentle contrast boost
    quant = cv2.convertScaleAbs(quant, alpha=1.15, beta=0)
    return quant

def ink_edges(bgr: np.ndarray, canny1: int = 80, canny2: int = 160, thickness: int = 1) -> np.ndarray:
    """Find bold black edges on white background."""
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.bilateralFilter(gray, d=7, sigmaColor=50, sigmaSpace=50)
    edges = cv2.Canny(gray, canny1, canny2)

    if thickness > 1:
        kern = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (thickness, thickness))
        edges = cv2.dilate(edges, kern, iterations=1)

    ink = np.full_like(bgr, 255)
    ink[edges > 0] = (0, 0, 0)
    return ink

def multiply_blend(bgr: np.ndarray, overlay_bgr: np.ndarray) -> np.ndarray:
    """Multiply blend (both uint8 BGR)."""
    a = bgr.astype(np.float32) / 255.0
    b = overlay_bgr.astype(np.float32) / 255.0
    out = (a * b) * 255.0
    return np.clip(out, 0, 255).astype(np.uint8)

def halftone_dots(bgr: np.ndarray, pitch: int = 8, min_dot: float = 0.0, max_dot: float = 0.85) -> np.ndarray:
    """
    Create a black-on-white dot screen overlay (Ben-Day feel) based on brightness.
    - pitch: pixels per cell (>= 2)
    - min_dot/max_dot: min/max radius proportion of half-cell (0..1)
    """
    h, w = bgr.shape[:2]
    pitch = max(2, int(pitch))

    lum = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY).astype(np.float32) / 255.0
    inv = 1.0 - lum  # dark areas -> larger dots

    # Create a white RGB canvas in PIL and draw on it
    base = np.full((h, w, 3), 255, dtype=np.uint8)
    pil_overlay = Image.fromarray(base[:, :, ::-1]).convert("RGB")  # to RGB
    draw = ImageDraw.Draw(pil_overlay)

    half = pitch / 2.0
    for y in range(0, h, pitch):
        y0 = min(y + pitch, h)
        for x in range(0, w, pitch):
            x0 = min(x + pitch, w)
            cell = inv[y:y0, x:x0]
            if cell.size == 0:
                continue
            v = float(np.mean(cell))  # 0..1
            r = (min_dot + (max_dot - min_dot) * v) * half
            if r <= 0.5:
                continue
            cx, cy = x + half, y + half
            bbox = (cx - r, cy - r, cx + r, cy + r)
            draw.ellipse(bbox, fill=(0, 0, 0))

    # Back to BGR numpy (avoid draw.im; ensure 3D array)
    overlay_rgb = np.array(pil_overlay)               # HxWx3 RGB
    overlay_bgr = overlay_rgb[:, :, ::-1].copy()      # to BGR

    # Slight transparency for a printed look
    overlay_bgr = cv2.addWeighted(overlay_bgr, 0.7, np.full_like(overlay_bgr, 255), 0.3, 0)
    return overlay_bgr

def paper_vignette(bgr: np.ndarray, strength: float = 0.25) -> np.ndarray:
    """Soft vignette to simulate print falloff."""
    h, w = bgr.shape[:2]
    y, x = np.ogrid[:h, :w]
    cy, cx = h / 2.0, w / 2.0
    dist = np.sqrt(((x - cx) / (0.9 * w)) ** 2 + ((y - cy) / (0.9 * h)) ** 2)
    mask = 1.0 - np.clip(dist, 0, 1)
    mask = (mask * (1 - strength) + strength)
    out = (bgr.astype(np.float32) * mask[..., None]).clip(0, 255).astype(np.uint8)
    return out

def add_border_and_caption(img: Image.Image, border_px: int = 40,
                           caption: Optional[str] = None,
                           caption_h: int = 140,
                           font_path: Optional[str] = None) -> Image.Image:
    """Add white border; if caption, add a bottom box with text."""
    w, h = img.size
    bottom_extra = caption_h if caption else 0
    out = Image.new("RGB", (w + border_px * 2, h + border_px * 2 + bottom_extra), "white")
    out.paste(img, (border_px, border_px))

    if caption:
        draw = ImageDraw.Draw(out)
        y0 = border_px + h + 8
        draw.line([(border_px, y0), (border_px + w, y0)], fill="black", width=4)

        font = load_font(42, preferred=font_path)
        # textbbox returns (l,t,r,b) even when drawn at (0,0) -> width = r-l, height = b-t
        l, t, r, b = draw.textbbox((0, 0), caption, font=font)
        tw, th = (r - l), (b - t)
        tx = (out.width - tw) // 2
        ty = y0 + ((border_px + bottom_extra - (y0 - border_px)) - th) // 2
        draw.text((tx, ty), caption, font=font, fill="black")

    return out

def draw_speech_bubble(base: Image.Image, text: str, pos: Tuple[int, int],
                       font_path: Optional[str] = None) -> Image.Image:
    """Add a simple speech bubble: rounded rectangle + tail + text."""
    out = base.copy()
    draw = ImageDraw.Draw(out)
    font = load_font(36, preferred=font_path)

    padding = 20
    l, t, r, b = draw.textbbox((0, 0), text, font=font)
    tw, th = (r - l), (b - t)

    bx, by = pos
    bw, bh = tw + padding * 2, th + padding * 2
    radius = 22

    rect = (bx, by, bx + bw, by + bh)
    draw.rounded_rectangle(rect, radius=radius, fill="white", outline="black", width=4)

    tail = [(bx + bw * 0.22, by + bh), (bx + bw * 0.35, by + bh + 35), (bx + bw * 0.40, by + bh)]
    draw.polygon(tail, fill="white", outline="black")
    draw.line([tail[0], tail[1]], fill="black", width=4)
    draw.line([tail[1], tail[2]], fill="black", width=4)

    draw.text((bx + padding, by + padding), text, font=font, fill="black")
    return out


# ---------------------------
# Pipeline
# ---------------------------
def comicify(
    pil_img: Image.Image,
    k_colors: int = 8,
    edge_thick: int = 2,
    canny_low: int = 80,
    canny_high: int = 160,
    dot_pitch: int = 8,
    dot_min: float = 0.05,
    dot_max: float = 0.9,
    target_long_side: int = 1600,
) -> Image.Image:
    # Resize (preserve aspect), fit long side
    w, h = pil_img.size
    if max(w, h) != target_long_side:
        if w >= h:
            new_w = target_long_side
            new_h = int(h * (target_long_side / w))
        else:
            new_h = target_long_side
            new_w = int(w * (target_long_side / h))
        pil_img = pil_img.resize((new_w, new_h), Image.LANCZOS)

    bgr = pil_to_np(pil_img)

    # 1) Posterize color
    color = posterize_kmeans(bgr, k=k_colors)

    # 2) Inked edges (black on white)
    edges = ink_edges(color, canny1=canny_low, canny2=canny_high, thickness=edge_thick)

    # Combine edges onto color (place black where edges are)
    edge_gray = cv2.cvtColor(edges, cv2.COLOR_BGR2GRAY)
    edge_mask = (edge_gray < 128)
    color_inked = color.copy()
    color_inked[edge_mask] = (0, 0, 0)

    # 3) Halftone overlay, then multiply to imprint dots
    dots = halftone_dots(color_inked, pitch=dot_pitch, min_dot=dot_min, max_dot=dot_max)
    dotted = multiply_blend(color_inked, dots)

    # 4) Subtle vignette
    vign = paper_vignette(dotted, strength=0.20)

    return np_to_pil(vign)


def main():
    parser = argparse.ArgumentParser(description="Turn a photo into a comic-book panel.")
    parser.add_argument("--input", required=True, help="Path to input image")
    parser.add_argument("--output", default=None, help="Output path (defaults to *_comic.png)")
    parser.add_argument("--k_colors", type=int, default=8, help="Number of posterize colors (6–12 good)")
    parser.add_argument("--edge_thick", type=int, default=2, help="Edge thickness (1–4)")
    parser.add_argument("--canny", type=str, default="80,160", help="Canny thresholds low,high")
    parser.add_argument("--dot_pitch", type=int, default=8, help="Halftone dot pitch (smaller = more dots)")
    parser.add_argument("--dot_min", type=float, default=0.05, help="Min dot radius proportion (0..1)")
    parser.add_argument("--dot_max", type=float, default=0.9, help="Max dot radius proportion (0..1)")
    parser.add_argument("--long", type=int, default=1600, help="Long side in pixels")
    parser.add_argument("--border", type=int, default=40, help="Border pixels")
    parser.add_argument("--caption", type=str, default=None, help="Bottom caption text")
    parser.add_argument("--caption_h", type=int, default=140, help="Caption box height")
    parser.add_argument("--bubble", type=str, default=None, help="Speech bubble text")
    parser.add_argument("--bubble_pos", type=parse_xy, default=None, help="Speech bubble top-left 'x,y'")
    parser.add_argument("--font", type=str, default=None, help="Optional TTF font path for caption/bubble")
    args = parser.parse_args()

    c1, c2 = [int(x) for x in args.canny.split(",")]

    # Load image (use absolute path or quotes if spaces)
    img = Image.open(args.input).convert("RGB")
    comic = comicify(
        img,
        k_colors=args.k_colors,
        edge_thick=args.edge_thick,
        canny_low=c1,
        canny_high=c2,
        dot_pitch=args.dot_pitch,
        dot_min=args.dot_min,
        dot_max=args.dot_max,
        target_long_side=args.long,
    )

    # Add border + optional caption
    out = add_border_and_caption(
        comic,
        border_px=args.border,
        caption=args.caption,
        caption_h=args.caption_h,
        font_path=args.font,
    )

    # Optional speech bubble
    if args.bubble:
        pos = args.bubble_pos if args.bubble_pos else (int(out.width * 0.06), int(out.height * 0.06))
        out = draw_speech_bubble(out, args.bubble, pos, font_path=args.font)

    # Default output name
    if not args.output:
        base, ext = os.path.splitext(args.input)
        args.output = f"{base}_comic.png"

    out.save(args.output)
    print(f"Saved: {args.output}")
    print("Tips: try --k_colors 6 --edge_thick 3 --dot_pitch 10 --dot_max 0.8 for a pulp look.")


if __name__ == "__main__":
    main()
